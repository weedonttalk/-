export class Tile { constructor(p,q){ this.p=p; this.q=q; } isDouble(){ return this.p===this.q; } flipped(){ return new Tile(this.q,this.p);} toString(){ return `${this.p}|${this.q}`; } }
export class Deck { constructor(maxPip=6){ this.maxPip=maxPip; this.tiles=[]; for(let i=0;i<=maxPip;i++) for(let j=i;j<=maxPip;j++) this.tiles.push(new Tile(i,j)); } shuffle(){ for(let i=this.tiles.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [this.tiles[i],this.tiles[j]]=[this.tiles[j],this.tiles[i]]; } } draw(){ return this.tiles.pop()||null; } }
export class Board { constructor(){ this.center=null; this.lines={L:[],R:[],U:[],D:[]}; } _initialEnd(side){ if(!this.center) return null; return (side==='L'||side==='U')? this.center.p : this.center.q; } end(side){ const arr=this.lines[side]; if(!this.center) return null; if(arr.length===0) return this._initialEnd(side); return arr[arr.length-1].q; } can(side,t){ if(!this.center) return true; const e=this.end(side); return t.p===e || t.q===e; } place(side,t){ if(!this.center){ this.center=t; return; } const e=this.end(side); if(e===null) throw new Error('Invalid board'); const orient=(t.p===e)? t : (t.q===e? t.flipped(): null); if(!orient) throw new Error('Invalid placement'); this.lines[side].push(orient); } snapshot(){ return { center: this.center? [this.center.p,this.center.q] : null, L:this.lines.L.map(t=>[t.p,t.q]), R:this.lines.R.map(t=>[t.p,t.q]), U:this.lines.U.map(t=>[t.p,t.q]), D:this.lines.D.map(t=>[t.p,t.q]), ends:{ L:this.end('L'), R:this.end('R'), U:this.end('U'), D:this.end('D') } }; } }
export class Bot { choose(board, hand){ const dirs=['L','R','U','D']; const legal=[]; if(!board.center){ for(const t of hand){ for(const d of dirs) legal.push([d,t]); } } else { for(const t of hand){ for(const d of dirs){ if(board.can(d,t)) legal.push([d,t]); } } } if(!legal.length) return null; const freq=new Map(); const inc=n=>freq.set(n,(freq.get(n)||0)+1); for(const t of hand){ inc(t.p); inc(t.q);} const ends=board.snapshot().ends; for(const d of dirs){ if(ends[d]!=null) inc(ends[d]); } const score=([d,t])=>{ let s=t.p+t.q; if(t.isDouble()) s+=2; s+=(freq.get(t.p)||0)+(freq.get(t.q)||0); const len=board.lines[d].length; s+=Math.max(0,2-len); return s; }; return legal.reduce((a,c)=> score(a)>score(c)? a:c); } }
